////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if RAVNO_I_ZAPATAYA
////////////////////////////////////////////////////////////////////

#if ОПЕРАТОР_РАВНО

ОПЕРАТОР РАВНО или ОПЕРАЦИЯ ПРИСВАИВАНИЯ a = b
КОРОТКОЕ ОБЪЯСНЕНИЕ : Пытается поместить то, что стоит от РАВНО справа в то, что стоит от равно слева

ПОЛНОЕ ОБЪЯСНЕНИЕ:
имеет определённую последовательность действий:
1 Шаг: смотрит на то, что стоит слева, и определяет какого оно ТИПА !
2 Шаг: Смотрит на то, является ли то, что стоит справа (*)числом, (**)переменной, выражением или функцией
3 Шаг: Если выражение или функция, то полностью выполняет функцию или вычисляет выражение пока
не будет получен конечный результат работы функции или вычисления выражения
4 Шаг: Этот результат (*)число, (**)переменная проверяется на то, какой у него тип
5 Шаг: Выполняется попытка поместить то, что стоит от РАВНО справа в то, что стоит от равно слева, если типы совпадают
Если типы не совпадают, или произойдут другие ошибки, на этапе компиляции оператор РАВНО выведет их в список ошибок компиляции

#endif

///////////////////////////////

#if ОПЕРАТОР_ЗАПЯТАЯ

ОПЕРАТОР ЗАПЯТАЯ a = 1, b = 2, с = 3, d = 4, e = 5;
ОБЪЯСНЕНИЕ: Идёт слева направо и выполняет, сначала то, что стоит от него слева,
	после смотрит на то что справа от неё, если то, что справа относится к ещё одной запятой, что стоит правее,
	то, передаёт управление следующей запятой, которая снова выполняет выражение слева от неё и т.д. до последнего выражения,
	которое стоит с правой стороны, если после последнего выражения справа запятая видит точку_с_звпятой, то она
	выполняет выражение стоящее справа от неё и завершает свою работу.

	Причём! Результат каждого посчитанного выражения слева от запятой, будет суммироваться
	с каждым последующим выражением справа от запятой.

В нашем примере: первая запятая выполнит выражение стоящее от неё слева, т.е. a = 1, после чего увидит, что после выражения b = 2 стоит вторя запятая, значит она
передаст управление второй запятой, вторая запятая выполнит выражение стоящее от неё слева, т.е. b = 2, после чего увидит, что после выражения c = 3 стоит третья запятая, и т.д.
до последней, которая после выражения e = 5 справа от себя увидит, что после него стоит ";", и значит, ей останется выполнить только то, что стоит слева от неё и на этом закончить.

#endif

//* // Применим вышеописанные знания на практике
void main()
{
	int k = 0;
	//k = k + 1, k = k + 1, k = k + 1; // k будет в итоге равно трём
	k = k + 1, k = k - 1, k = k + 1; // k будет в итоге равно одному

	int a = 1, b = 2, c = 3;
	a = b = c; // все три будут равны ТРЁМ
	
	// ИБО последовательно справа на лево:
	// из с тройку поместим в b, в итоге и в с и в b тройки
	// и после из b в котором тройка постим её в а
	// Итог: все три будут равны ТРЁМ
}
//*/

#endif // RAVNO_I_ZAPATAYA

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if PEREMENNIE
////////////////////////////////////////////////////////////////////

#if ZAKOMMEHTiL // Не хочу чтбы этот текст в студии был зелёными комментами
			
Все нижеперечисленные типы пременных называются  СТАНДАРТНЫЕ ТИПЫ Данных,  тоесть они
Вшиты в Операционные системы и по названию типа ОС сразу понятно какого размера пемеренная
---------------------------------------------------------------------------
ИМЯ					РАЗМЕР		МИНИМАЛЬНОЕ / МАКСИМАЛЬНОЕ
(СЛОВО ЯЗЫКА)		В БАЙТАХ	ВОЗМОЖНО ПРИНИМАЕМЫЕ ЗНАЧЕНИЯ
---------------------------------------------------------------------------
Пустой тип .... сырые данные, может в последствии быть преобразован в любой другой тип
Специалный Тип указывающий, что функция НЕ возвращает никакого значения никакого типа
void

Логические
bool				1	false (0) / true (любое число отличное от нуля хоть положит. хоть отрицат.)

Целочисленные
char				1	-128 / 127		— это числовая переменная, которая используется для 
unsigned char		1	0 / 255			  представления ASCII символов.	
wchar_t				2/4 0 / 65535		— это числовая переменная, для представления UNICODE символов. 
short int			2	-32768 / 32767
short				2	-32768 / 32767
unsigned short		2	0 / 65535
int					4	-2 147 483 648 / 2147483647			- (2^31) - 1
unsigned int		4	0 / 4294967295						- (2^32) - 1
long int			4	-2147483648 / 2147483647
long				4	-2147483648 / 2147483647
unsigned long		4	0 / 4294967295
long long int		8	-38748423598798  / 38748423598798
long long			8	-38748423598798  / 38748423598798	- (2^63) - 1
unsigned long long	8	0 / 18459874294967295				- (2^64) - 1

Типы данных с плавающей точкой
float				4	-2147483648.0 / 2147483647.0
long float			8	-9223372036854775808.0 / 9 223 372 036 854 775 807.0
double				8	-9223372036854775808.0 / 9 223 372 036 854 775 807.0

Строковые типы данных
char				1	'a'  - односимвольная переменная в одинарных ковычках (и число и символ одновременно)
std::string			STD	"stroka" - многосимвольная строка в двойных ковычках (НЕСТАНДАРТНЫЙ ТИП ДАННЫХ!!!)

#endif // ZAKOMMEHTiL

#include <string>

void main()
{
	// логическая
	bool b = true;
	
	// числовые
	int i = 99;
	int n = 99;
	
	double bbb; // так делать не надо, ибо компилятор оставит в переменной "мусор" случайное число

	double dl = 10.73;	// (!!!) ВО МНОГИХ ЯЗЫКАХ ПРОГРАММИРОВАНИЯ НЕ ЧЕРЕЗ ЗАПЯТУЮ
						//, А ЧЕРЕЗ ТОЧКУ задаются числа с плаваюшей точкой !!!
	// строковые
	char ch = 'f';				// буква f находится в ASCII таблице на 102 позиции
	std::string str = "stroka"; // 's''t''r''o''k''a''/0'
								// Строка в двойных кавычках это набор дург за другом идущих символов 
								// в КОНЦЕ после последнего символа такая строка заканчивается 
								// Символом ЗАКРЫВАЮЩИЙ НОЛЬ '/0' 

	int k = ch; // переменная ch хранит как букву f, так и число 102, своей позиции в таблице ASCII-кодов
				// так что в переменную k запишется именно ЧИСЛО 102

	// интересный факт [-32768 / 32767]:
	short s_1 = 32767; // 32767
	short s_2 = 32768; // -32768
	short s_3 = 32769; // -32767

	// unsigned short [0 / 65535]
	unsigned short	us__2 = -2;		// 65534
	unsigned short	us__1 = -1;		// 65535
	unsigned short	us_0  = 0;		// 0
	unsigned short	us_1  = 65535;	// 65535
	unsigned short	us_2  = 65536;	// 0
	unsigned short	us_3  = 65537;	// 1

	//char [ -128 / 127 ]
	char ch__3 = -130;  // 126
	char ch__2 = -129;  // 127
	char ch__1 = -128;  // 128
	char ch_0 = 0;      // 0
	char ch_1 = 126;	// 126
	char ch_2 = 127;	// 127
	char ch_3 = 128;	// -128

	char ch_4 = 52;
	char ch_5 = 53;

	char ch_a = 'a';
	char ch_b = 'b';
	char ch_y = 'y';
	char ch_z = 'z';

	char ch_A = 'A';
	char ch_Z = 'Z';

}

#endif // PEREMENNIE


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if PREOBRAZOV_TIPOV
////////////////////////////////////////////////////////////////////

#include <string>

void main()
{
	int a = 0;
	a = a + 1, a = a + 1, a = a + 1;

	////////////////////////////////////////////////////////////////////
	// АВТОМАТИЧЕСКОЕ преобразование типов

	bool b = true;
	b = 0;
	b = 3;
	b = 0;
	b = -12;

	char ch = 'a';
	char ch_4 = 52;
	char ch_5 = 53;

	char ch_a = 'a';
	char ch_b = 'b';
	char ch_y = 'y';
	char ch_z = 'z';

	char ch_A = 'A';
	char ch_Z = 'Z';


	////////////////////////////////////////////////////////////////////
	// ЯВНОЕ / НЕЯВНОЕ  преобразование типов

	int n = 99;
	double d = 10.73;

	// НЕЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ
	n = d;
	//int n = double d;
	// а должно быть
	//int n = int d

	// Что же скрыла операция "равно" ?
	int nn = 99;
	double dd = 10.73;
	// ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ [1] первый доступный вариант
	dd = (double)nn; 
	//double dd = double nn;

	// ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ [2] второй доступный вариант
	dd = static_cast<double>(nn);

	// НЕЯВНОЕ ПРЕОБРАЗОВАНИЕ - когда программист не указывает в скобках справа от равно к какому типу преобразовать
	// выражение стоящее справа от оператора РАВНО, и отдаёт эту работу в руки компилятора.
	// Комплятор однако НЕ ВСЕГДА может справтся с преобразованием сам (см. ниже)

	// ЯВНОЕ ПРЕОБРАЗОВАНИЕ - когда программист справа от равно ЯВНО прописывает в скобках ТИП к которому нужно преобразовать
	// выраженгие стоящее справа от оператора равно
	// ИЛИ использует конструкцию:  static_cast< тип данных >( переменная или число )

	// nn будет преобразовано в тот тип который является конечным, тоесть К КОТОРОМУ Приравнивают


	// Можно ли в обратную сторону:
	int nnn = 99;
	double ddd = 10.73;
	// Можно, но преобразование произойдёт с потерей того, что стоит после запятой, ибо у int после точки "всегда нули"
	nnn = ddd;

	// Тут эффект будет тот же:
	ddd = 10.854;
	nnn = (int)nn;
	ddd = 211.2345;
	nnn = static_cast<int>(nn);

	
	// О Возможных потерях данных при преобразовании нас будет предупреждать компилятор:
	int n_5 = 5;
	int n_3 = 3;
	int nR = 0;
	nR = n_5 / n_3; // = 1,6 но получили 1


	int n_15 = 15;
	int n_2  = 2;
	int nResult = 0;

	float fl_15 = 15.0;
	float fl_2 = 2.0;
	float flResult = 0.0;
	
	nResult  = n_15  / n_2;  // 15  /  2  = 7
	nResult  = fl_15 / n_2;  // 
	nResult  = n_15  / fl_2; // 
	nResult  = fl_15 / fl_2; //

	flResult = n_15 / n_2;   // 15  /  2  = 7.0
	flResult = fl_15 / n_2;  // 15   / 2.0 = 7.5
	flResult = n_15 / fl_2;  // 15.0 / 2   = 7.5
	flResult = fl_15 / fl_2; // 15.0 / 2.0 = 7.5



	// СИМВОЛЫ И СТРОКИ В СИ++ //http://cppstudio.com/post/437/
	std::string str = "stroka"; // 's''t''r''o''k''a''/0'
	int nStr = str[0];
}

#endif // PREOBRAZOV_TIPOV



////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if FUNKZII
////////////////////////////////////////////////////////////////////

#if ZAKOMMEHTiL

возвращаемый_тип название_функции(ти_парам_1 параметр_1, ти_парам_2 парам_2, ..., ти_парам_n парам_n)
{
  ТЕЛО ФУНКЦИИ
}

//тип_возвращаемого_значения название_функции(ти_парам_1 параметр_1, ти_парам_2 парам_2, ..., ти_парам_n парам_n)
//{
//	ТЕЛО ФУНКЦИИ
//}

//void main() - void значит, что функция НИЧЕГО не возвращает и в ней не нужно ключевое слово return.
//int main() - значит, что функция вернёт переменную или число типа int, и эта переменная или число будет стоять после return.

int addOne(int x)
{
	x = x + 1;
	return x;
}


int example_function()
{
	return 1;
}

/*
void main()
{
	//int resultat = 0;
	//int a = 1;
	//resultat = addOne(a);

	int e = 0;
	e = example_function();

}
//*/

int main()
{
	return 0;
}



#endif // ZAKOMMEHTiL

#include <iostream> // std::cout, std::cin

// ГЛОБМАЛЬНАЯ ПЕРЕМЕННАЯ - Переменная заданная в ГЛОБАЛЬНОЙ области
// Она по факту не содежится ни в одном теле ни одной функции
int g_globalnajaPeremennaja = 0;

void useGlobalPerem()
{
	g_globalnajaPeremennaja++;
}

void compareParams(int param_1, int param_2)
{
	if (param_1 < param_2)
	{
		std::cout << "первый параметр меньше, чем второй";
	}
	else
	{
		std::cout << "первый параметр больше, чем второй";
	}
	// void => return не нужен, более того компилятор тут на него ругнётся
}

int increaseNumber(int num)
{
	return num + 1;
}

int addTwoNumbersBad(int param_1, int param_2)
{
	int result = 0;
	result = param_1 + param_2;
	return result;
}

int addTwoNumbersGood(int param_1, int param_2)
{
	return (param_1 + param_2);
}

float addThreeNumbers(float x, float y, float z)
{
	return (z + x + y);
}

///////////////////////////////////////////////////
// Площадь треугольника: S = (1/2)(a * h), где a - сторона треугольника, h - высота треугольника
int calcTriangleAreaBad(int triangleSide, int triangleHeight)
{
	int triangleArea = 0;
	triangleArea = (triangleSide * triangleHeight) / 2;
	return triangleArea;
}

float calcTriangleAreaOk(float triangleSide, float triangleHeight)
{
	float triangleArea = 0;
	triangleArea = (triangleSide * triangleHeight) / 2;
	return triangleArea;
}

float calcTriangleAreaPerfect(float triangleSide, float triangleHeight)
{
	return (0.5 * (triangleSide * triangleHeight) );
}

///////////////////////////////////////////////////
// Вычисление Дискрименанта
int calcDescriminant(int a, int b, int c)
{
	return ( b*b - 4 * a*c );
}

///////////////////////////////////////////////////
// Вычисление Решений
double calcX1(double a, double b, int discriminant)
{
	return (-b + sqrt((double)discriminant)) / (2 * a);
}

double calcX2(double a, double b, int discriminant)
{
	return (-b - sqrt((double)discriminant)) / (2 * a);
}

void main()
{
	setlocale(LC_ALL, "Russian");


	std::cout << "Глобальная перемення = " << g_globalnajaPeremennaja << std::endl;
	g_globalnajaPeremennaja++;
	std::cout << "Глобальная перемення = " << g_globalnajaPeremennaja << std::endl;
	useGlobalPerem();
	std::cout << "Глобальная перемення = " << g_globalnajaPeremennaja << std::endl;


	int a = 2, b = 3;
	compareParams(a, b);
	a = 3, b = 3;
	compareParams(a, b);
	a = 4, b = 3;
	compareParams(a, b);


	int number = 5;
	number = increaseNumber(number);
	number = increaseNumber(number);
	number = increaseNumber(number);
	std::cout << "Число = " << number << std::endl;


	int param_1 = 12, param_2 = 2, res = 0;
	res = addTwoNumbersBad(param_1, param_2);
	std::cout << "Cумма двух чисел = " << res << std::endl;

	int first = 10, second = 21, result = 0;
	result = addTwoNumbersGood(first, second);
	std::cout << "Cумма двух чисел "<< first << " и "<< second <<" = " << result << std::endl;


	float x = 1.01, y = 2.02, z = 3.03, r = 0.0;
	r = addThreeNumbers(x, y, z);
	//std::cout << "Cумма трёх чисел = " << r << std::endl;
	std::cout << "Числа: " << x << " ; " << y << " ; " << z << " ; " std::endl;
	std::cout << "Cумма трёх чисел = " << r << std::endl; // ДЗ - дописать чтобы выводились три числа на консоль


	///////////////////////////////////////////////////
	// Площадь треугольника: S = (1/2)(a * h), где a - сторона треугольника, h - высота треугольника
	int nTriangleSide = 3;
	int nTriangleHeight = 10;
	int nTriangleArea = 0;

	nTriangleArea = calcTriangleAreaBad(nTriangleSide, nTriangleHeight);


	float flTriangleSide = 3;
	float flTriangleHeight = 10;
	
	float flTriangleArea = calcTriangleAreaOk(flTriangleSide, flTriangleHeight);
	
	flTriangleArea = calcTriangleAreaPerfect(flTriangleSide, flTriangleHeight);


	// Нахождение решений квадратного уравнения
	double a = 10, b = 20, c = 4;
	std::cout << "Уравнение: " << a << "(x^2) + " << b << "(x) + " << c << ";" << std::endl;
	std::cout << "Решения: " << std::endl;
	std::cout << "x1 = " << calcX1( a, b, calcDescriminant(a, b, c) ) << std::endl;
	std::cout << "x2 = " << calcX2( a, b, calcDescriminant(a, b, c) ) << std::endl;
}

#endif // FUNKZII


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if MATEMAT_OPERAZII // МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ
////////////////////////////////////////////////////////////////////

#if ZAKOMMEHTiL

Унарный плюс	b += a	то же самое, что  b = b + a
Унарный мину	b -= a	то же самое, что  b = b - a


Присваивание	a = b
Сложение		a + b	
Вычитание		a - b	
Умножение		a * b	
Деление			a / b	

Операция модуль a % b	то же самое, что в математикe a mod(b)
						(остаток от деления целых чисел)
Пример: 6 % 2 =  6 mod(2) = 0, ибо 6 делится на 2 без остатка
		8 % 3 =  8 mod(3) = 2, ибо отсток от деления восьми на три будет двойка

Взять значение
по модулю		abs(а)	то же самое что в математике |a|

Инкремент		++a		увеличивает a на единицу
префиксный				(НЕ создаёт временную переменную (!!!))

Инкремент		a++		увеличивает a на единицу
постфиксный				(создаёт временную переменную (!) )

СУТЬ И РАЗНИЦА:
int a = 2;		//a = 2
int b = ++a;	//b = 3; a = 3; // сначала увеличит a и после даст приравять b к a
int c = a;		//c = 3; a = 3;

int a = 2;		//a = 2
int b = a++;	//b = 2; a = 3; // сначала приравняет b к a, и ТОЛЬКО после увеличит себя 
int c = a;		//c = 3; a = 3;

a++ то же савмое, что a = a + 1;


Декремент		--a	
префиксный
Декремент		a--
постфиксный

СУТЬ И РАЗНИЦА:
int a = 2, b = 0, c = 0;	a = 2; b = 0; c = 0
b = --a;					b = 1; a = 1; // сначала уменьшит a и после даст приравять b к a
c = a;						c = 1; a = 1;

int a = 2, b = 0, c = 0;	a = 2; b = 0; c = 0
b = a--;					b = 2; a = 1; // сначала приравняет b к a, и ТОЛЬКО после уменьшит себя 
c = a;						c = 1; a = 1;

a-- то же савмое, что a = a - 1;

#endif // ZAKOMMEHTiL

#include <stdio.h>	// printf
#include <math.h>	// abs, sqrt, pow
#include <cmath>

void main()
{
	bool b_2  = -20;
	bool b_1  = -1;
	bool b_0  = 0;
	bool b_11 = 1;
	bool b_12 = 2;

	int bbb = 17;
	int ccc = 17 % 10; // 7

	int bb = 17;
	int cc = 17 / 10; // 1


	int inc_a = 2;		 //a = 2
	int inc_b = ++inc_a; //b = 3; a = 3; // сначала увеличит a и после даст приравять b к a
	int inc_c = inc_a;	 //c = 3; a = 3;

	int a_inc = 2;		 //a = 2
	int b_inc = a_inc++; //b = 2; a = 3; // сначала приравняет b к a, и ТОЛЬКО после увеличит себя 
	int c_inc = a_inc;	 //c = 3; a = 3;

	
	int minusVar = -200;
	// модуль от -200 
	int moduleVar = abs(minusVar);

	// возвести в степень 
	int res = 0;
	double base = 4;
	int exponent = 5;
	
	// можно подставлять и просто числа не используя переменные
	res = pow(2.0, 3); // два в кубе
	// вариант с переменными
	res = pow(base, exponent); // два в кубе
	int stepen = pow(6.0, 2);


	// Функция взятия Корня:
	double param, result;
	param = 1024.0;
	result = sqrt(param);
	
	printf("sqrt(%f) = %f\n", param, result);


}

#endif // MATEMAT_OPERAZII





////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if LOGI4ES_OPERAZII // ЛОГИЧЕСКИЕ ОПЕРАЦИИ - ВСЕ ВОЗВРАЩАЮТ  true  или  false
////////////////////////////////////////////////////////////////////

#if ZAKOMMEHTiL

a > b 
Произойдёт следуюшее:
Если a действительно больше b, то операция > веронёт после своего выполнения true
Если a окажется меньше или равной b, то операция > веронёт после своего выполнения false

ПРОВЕРКА НА Больше				a > b
ПРОВЕРКА НА Меньше				a < b
ПРОВЕРКА НА Больше или равно	a >= b
ПРОВЕРКА НА Меньше или равно	a <= b

ПРОВЕРКА НА Равенство			a == b
ПРОВЕРКА НА Неравенство			a != b
ИНВЕРСИЯ c true на false или с false на true  !a

bool a = true;
a = !a; // в переменную а запишется false

#endif // ZAKOMMEHTiL


void main()
{
	int a = 3;
	int b = 4;
	int c = 5;
	int d = 3;

	/*
	if(если результат опеции в скобках ... )
	{
		// ... ИСТИНА, то есть true. Тогда заходим в ТЕЛО "операторв" if
	}

	// ... ЛОЖЬ, то есть false. Тогда обходим ТЕЛО "операторв" if и 
	// продолжаем исполнять код после закрывающейся скобки оператора if
	*/


	if (a == b)
	{
		int u = 0;
	}

	if (a < b)
	{
		int u = 0;
	}

	if (a == d)
	{
		int u = 0;
	}


	if (a != d)
	{
		int u = 0;
	}

	if (a != c)
	{
		int u = 0;
	}

}
#endif // LOGI4ES_OPERAZII


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
#if OPERATORI // ОПЕРАТОРЫ
////////////////////////////////////////////////////////////////////

#if ZAKOMMEHTiL

// условный оператор
if(выражение)
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение оказалось  true
}
// Обходим ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение оказалось  false


////////////////////////////////////////////////////////////////////
// условный оператор
if (выражение)
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение оказалось  true
}
else
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА else ЕСЛИ выражение оказалось  false
}

////////////////////////////////////////////////////////////////////
// ТЕРНАРНЫЙ оператор

//   IF   ?     THEN      :      ELSE
(Условие) ? (Выражение_1) : (Выражение_2);

// Проверяет Условие и ЕСЛИ
// Условие ИСТИНО, т.е. true  => выполняет только Выражение_1
// Условие ЛОЖНО,  т.е. false => выполняет только Выражение_2

// ВАРИАНТ 1
int koef = 0;
if(stag > 5) // если Стаж больше 5-ти лет (*)
{
	koef = 7; // (*) скидка с большим коэффициентом
}
else        // если Стаж меньше или раен 5-ти годам (**)
{
	koef = 3; // (**) скидка с меньшим коэффициентом
}

// ВАРИАНТ 2
int koef = 0;
koef = (stag > 5) ? 7 : 3;
//(stag > 5) ? koef = 7 : koef = 3;

// Вариатны 1 и 2 одинаковые по сути, но вариант 2 короче и нет скобок (меньше места для манёвра, удобен для компактных условий)


////////////////////////////////////////////////////////////////////
// лестница из if else
if (выражение_1)
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение_1 оказалось  true
}
if (выражение_2) else // Переходим к следующему условию если выражение_1 в верхнем if-е оказалось ЛОЖЬ ! 
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение_2 оказалось  true
}
...
if (выражение_N) else // Переходим к следующему условию если выражение_N-1 в верхнем if-е оказалось ЛОЖЬ ! 
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА if ЕСЛИ выражение_N оказалось  true
}
else
{
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА else ЕСЛИ ВСЕ предыдущие Выражения от 1 до N оказались  false
}


////////////////////////////////////////////////////////////////////
// циклический оператор
while(выражение)
{
	// ЦИКЛИЧЕСКИ ЗАХОДИМ В ТЕЛО ОПЕРАТОРА while ПОКА выражение есть  true
	// Как только выражение стало  false  выходим из тела оператора  while
}

////////////////////////////////////////////////////////////////////
// циклический оператор
do
{
	// сразу заходит в тело
	// проверяет Выражение на true / false после того как доходит
	// до закрывающей фигурной скобки внутри do
}
while(выражение)

////////////////////////////////////////////////////////////////////
// циклический оператор
for(начальное_условие; выражение; операция_цикла)
{
	// 1 шаг: выполняет ПЕРВОЕ_УСЛОВИЕ, и всё что будет написано внутри ПЕРВОГО_УСЛОВИЯ
	//
	// 2 шаг: Проверяет что находится в ВЫРАЖЕНИИ:
	//		  Если в ВЫРАЖЕНИИ true,  то выполняем 3 Шаг и входим  внутрь тела (фигурных скобок)
	//		  Если в ВЫРАЖЕНИИ false, то выполняем 3 Шаг и выходим из     тела (фигурных скобок)
	// 3 шаг: выполняем ОПЕРАЦИЮ_ЦИКЛА
	//
	// ЦИКЛ
	// ЦИКЛИЧЕСКИ ВЫПОЛНЯЕМ Шаг 2 и Шаг 3
	// ЗАХОДИМ В ТЕЛО ОПЕРАТОРА for ПОКА выражение есть  true
	// Как только выражение стало  false  выходим из тела оператора  for
	// На каждом входе и даже перед выходом выполняем ОПЕРАЦИЮ ЦИКЛА
}

////////////////////////////////////////////////////////////////////
break;

  Оператор разрыва. Прерывает выполнение операторов while, do, for и switch.
  Он может содержаться только в теле этих операторов.

////////////////////////////////////////////////////////////////////
continue;

  Оператор продолжения. Передает управление на следующую итерацию в операторах цикла while, do, for.
  Он может содержаться только в теле этих операторов.

////////////////////////////////////////////////////////////////////
return [<выражение>];

  Оператор возврата. Возвращает то значение выражения переменной или функции,
	которая будет стоять слева от него, при этом СНАЧАЛА выполнится подсчёт возвращаемого
	значения и только как оно будет окончательно готово, оператор вернёт его 

	Может и ничего не возвращать, т.е. такая запись тоже допустима:
    return; 

////////////////////////////////////////////////////////////////////
switch (<выражение>)
{
	case константное_выражение_1:
		break;
	case <константное выражение 2>:
		break;
    ...
    case <константное выражение N>:
		break;
    [default: <операторы>]	// не обязателен
	[break;]				// формально не обязателен
} 

	Оператор ПЕРЕКЛЮЧЕНИЯ на один из вариантов среди имеющихся внутри него CASE-ов,
	Смотрит чему равно <выражение>, которое приходит ему в скобках  switch (<выражение>),
	Ищет среди CASE-ов, тот у которого  <выражение>  будет равно  <константному выражению 1 2 или N>
	и входит в этот CASE 

	ЕСЛИ указан default: То входим в него, если пришедшее в свич в скобки значение
		не равно ни однрому из чисел в имеюшихся кейсах

int n = 2;
switch (n)
{
	case 1:
		n = n + 1;
		break;
	case 2:  // Свич зайдёт в этот Кейс, ибо n = 2 и у кейса справа стоит два
		n = n - 1;	// выполнится эта строчка и n уменьшится на 1
		break;		// мы выйдем из свича => (*)
	case 3:
		n = 0;
		break;
    default:
	break;
} 
// (*) => вот на эту строчку

#endif // ZAKOMMEHTiL


void main()
{
  
  // Если маскимальная скорость машины больше 150 км/ч
  // То нам нужно расчитать её грузоподъёмность по одной формуле 
  // Если меньше, то нам нужно расчитать её грузоподъёмность по другой формуле
  int carFlyKoefficient = 2;
  int carDensity = 20;
  int carWeight = 50;
  int carSpeedMax = 100;

  int gruzPodjom = (carSpeedMax > 150) ? (carWeight * carDensity) : (carWeight * carDensity) / carFlyKoefficient;
	


  int n = 3;
 
  if (n == 3)
  {
	  int u = 0;
  }
 
  if (n != 3)
  {
	  int u = 0;
  }
  else
  {
	  int u = 0;
  }

  if (n < 1)
  {
	  int u = 0;
  }
  else if (n < 2)
  {
	  int u = 0;
  }
  else if (n < 3)
  {
	  int u = 0;
  }
  else if (n < 4)
  {
	  int u = 0;
  }
  else
  {
	  int u = 0;
  }



  while(n > 0)
  {
    n--; // n = n-1
  }

  do
  {
	  n--; // n = n-1
  } while (n > 0);



  for (int i = 0; i < 3; i++)
  {
	  int u = 0;
  }

  for (int i = 1; i < 5; i++)
  {
	  int u = i;
  }

  int ff = 1;
  int zz = 0;

  for (zz = 5; ff < zz; zz--)
  {
	  f = f + 1;
  }


  int b = 3;
  int u = 0;

  switch (b)
  {
    case 1:
		u = 1;
		break;
    case 2:
		u = 2;
		break;
	case 3:
		u = 3;
		break;
	case 4:
		u = 4;
		break;
	default:
		u = 5;
		break;
  }

  n = 3;
  while (n > 0)
  {
	  if (n == 1)
	  {
		  break;
	  }
	  n--; // n = n-1
  }

  n = 3;
  while (n > 0)
  {
	  if (n == 1)
	  {
		  continue;
	  }
	  n--; // n = n-1
  }

  n = 3;
  while (n > 0)
  {
	  if (n == 1)
	  {
		  return;
	  }
	  n--; // n = n-1
  }


  //Допускается и такое использование Свича:
  int e = 2; 
  switch (e)
  {
  case 1:
  case 2:
  case 3:
	  e = e * 3; // войдём сюда при e равном и 1 и 2 и 3
	  break;
  default:

	  break;
  }

  //
  // БЕСКОНЕЧНЫЙ ЦИКЛ
  //

  // ВАРИАНТ 1 - через for без условий
  for (;;)
  {
	  // всегда будем входить в цикл
  }

  // ВАРИАНТ 2 - через while с успешным условием
  while (true)
  {
	  // всегда будем входить в цикл
  }

  // ВАРИАНТ 3 - условие внутри for должно быть Истина или НЕ НОЛЬ
  for (;true;)
  {
	  // всегда будем входить в цикл
  }

  // ВАРИАНТ 4 - условие while должно быть Истина или НЕ НОЛЬ
  while (1)
  {
	  // всегда будем входить в цикл
  }


	

  // войдём 3 раза на 4-тый войдём в if и выйдем из цикла for
  int loop = 3;
  for (;;)
  {
    if (loop == 0)
    { break; }

    loop--;
  }

}

#endif // OPERATORI



#if NAMESPACE

// namespace - ключевое слово для задания ИМЕНОВАНОЙ области Видимости
//				Позволяет обращаться через конструкцию math_functions::
//				ко всему, что находится внутри этого нэймспейса

namespace math_functions
{
	float odin(float b, float d, float a)
	{
		float x1 = ((-b) - sqrt(d)) / (2 * a);
		return x1;
	}

	float dwa(float b, float d, float a)
	{
		float x1 = ((-b) + sqrt(d)) / (2 * a);
		return x1;
	}

	float descriminant(float b, float a, float c)
	{
		float d = pow(b, 2) - (4 * a * c);
		return d;
	}
}


void main()
{
	float x = 34.5;
	float y = 235.67;
	float z = 345.5;
	float res = 0.0;

	//res = odin(x, y, z);  // ERROR работать не будет !!! функция внутри нэймспейса
	res = math_functions::odin(x, y, z);

	res = math_functions::dwa(z, x, y);

	res = math_functions::descriminant(y, z, x);
}

#endif // NAMESPACE





#if ETRA_EXAMPLE_1

int summa(int x, int y, int z)
{
	// используем переменные в любом порядке
	int slog = z + y + x;
	return slog;
}

int func(int x)
{
	return x;
}

int main()
{
	int res = summa(1, 3, 2);

	res = summa(1 + 2, 2 - 1, 3 + 34 + 3 + 4 + 45 + 4 + 5 + 6 + 6);
	
	res = func(1 + 2 + 3); // то же самое, что  func(6);

	return 0;
}

#endif // ETRA_EXAMPLE_1



#if ETRA_EXAMPLE_2

double calcTriangleArea(float a, float h)
{
	float S1 = (1.0/2.0) * a * h;
	float S2 = 0.5 * a * h;
	float S3 = (a * h) / 2.0;

	return S3;
}


int main()
{
	calcTriangleArea(105, 420);

	return 0;
}

#endif // ETRA_EXAMPLE_2



#if ETRA_EXAMPLE_3

#include <iostream>

void quadratEquasionExample()
{
	float a, b, c, x1, x2, discriminant, realPart, imaginaryPart;
	std::cout << "Для a(x^2) + b(x) + c = 0; Введите коэффициенты a, b и c: ";
	std::cin >> a >> b >> c;
	discriminant = b*b - 4*a*c;

	if (discriminant > 0) {
		x1 = (-b + sqrt(discriminant)) / (2*a);
		x2 = (-b - sqrt(discriminant)) / (2*a);
		std::cout << "Решения целые и не равны." << std::endl;
		std::cout << "x1 = " << x1 << std::endl;
		std::cout << "x2 = " << x2 << std::endl;
	}

	else if (discriminant == 0) {
		std::cout << "Решения целые и равны" << std::endl;
		x1 = (-b + sqrt(discriminant)) / (2*a);
		std::cout << "x1 = x2 =" << x1 << std::endl;
	}

	else {
		realPart = -b/(2*a);
		imaginaryPart =sqrt(-discriminant)/(2*a);
		std::cout << "Решения - комплексные числа и различны" << std::endl;
		std::cout << "x1 = " << realPart << "+" << imaginaryPart << "i" << std::endl;
		std::cout << "x2 = " << realPart << "-" << imaginaryPart << "i" << std::endl;
	}
}

void main()
{
	void quadratEquasionExample()
}

#endif // ETRA_EXAMPLE_3




#if EXAMPLE_ALGORITM

////////////////////////////////////////////////////////////////////
// Реализовать свою функцию Фактореала
// Варинт_1
int factorial(int n)
{
	if (n < 0)  return 0; // если пользователь ввел отрицательное число возвращаем ноль

	int r = 1;
	for (int i = 1; i <= n; i++)
	{
		r = r * i;
	}
	return r;
}

int factorial(int n)
{
	int i;

	for (i = n - 1; i > 1; i--)
		n = n * i; //n *= i;

	return (n == 0) ? 1 : n;
}

// Варинт_2 через РЕКУРСИЮ
int Fact(int x)
{
	if (x == 0)
		return 1;

	return x * Fact(x - 1);
}

////////////////////////////////////////////////////////////////////
// Реализовать свою функцию возведения в степень
// Варинт_1
int integerPower(int base, int exponent)
{
	int x = 1;

	for (int count = 1; count <= exponent; count++)
	{
		x = x * base;
		//x *= base;
	}

	return x;
}

// Варинт_2
int integerPowerHelper(int base, int exponent, int result)
{
	if (exponent < 1)
		return result;
	return integerPowerHelper(base, --exponent, result*base);
}
int integerPower(int base, int exponent)
{
	return integerPowerHelper(base, exponent, 1);
}

// Варинт_3 через РЕКУРСИЮ
int intPower(int base, int exponent)
{
	if (exponent <= 1)
		return base;
	return  base * intPower(base, --exponent);
}




void main()
{
	////////////////////////////////////////////////////////////////////
	// Реализовать свою функцию Фактореала
	// Варинт_1
	int factorial(int n)

	// Варинт_2 через РЕКУРСИЮ
	int Fact(int x)

	////////////////////////////////////////////////////////////////////
	// Реализовать свою функцию возведения в степень
	// Варинт_1
	int integerPower(int base, int exponent)

	// Варинт_2
	int integerPower(int base, int exponent)
	{
		return integerPowerHelper(base, exponent, 1);
	}

	// Варинт_3 через РЕКУРСИЮ
	int intPower(int base, int exponent)
}

#endif // EXAMPLE_ALGORITM





#if EXAMPLE_WINAPI

#include <windows.h> // Чтобы использовать WinAPI

void popup(int x, int y)
{
	if (x > y)
	{
		MessageBoxA(0, "x > y", "x больше y", 0);
	}
	else
	{
		MessageBoxA(0, "x <= y", "x меньше или равно y", 0);
	}
}

int main()
{
	int a = 2;
	int b = 1;

	// передаём значения из переменных
	popup(b, a);

	// передаём значения
	popup(1, 3);

	return 0;
}

#endif
